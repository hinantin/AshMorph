# ------------------------------- 
# Total reduplication 
# ------------------------------- 

define Vow [a|e|i|o];
define Cons [{p}|{py}|{t}|{ty}|{k}|{ky}|{s}|{sh}|{ch}|{ts}|{tz}|{h}|{m}|{n}|{ny}|{r}|{ry}|{v}|{y}];
define EP [
  "[--][-a][+EP]" : {a} 
| "[--][-aa][+EP]" : {aa} 
];

define P=1 [
# 1st person singular 
  "[no-][VPers][1SG.S/A+][--]" : [{no}] ! 
| "[n-][VPers][1SG.S/A+][--]" : [{n}] ! 
# 2nd person singular 
| "[p-][VPers][2S/A+][--]" : [{p}] ! 
| "[pi-][VPers][2S/A+][--]" : [{pi}] ! 
# 3rd person (male) singular
| "[i-][VPers][3m.S/A+][--]" : [{i}] ! 
| "[y-][VPers][3m.S/A+][--]" : [{y}] ! 
# 3rd person (female) singular
| "[o-][VPers][3n.m.S/A+][--]" : [{o}] ! 
];

define RemoveBrackets %<|%> -> 0;

# FLAG: TOTREDUPCLASS01 / VRootTotRedupClass01 

source vroot.totredup.class01.foma 
define LexiconClass1 VRootTotRedupClass01in;

#define LexiconClass1 [ 
#  "[=koma+tot.redup@unb.copy.][VRoot][=to.row; to.paddle (ES: remar)]::[= (ES: remar.a_cada_rato)]":{koma}
#| "[=kya+tot.redup@unb.copy.][VRoot][=to.carry.load (on.the.back.holding.it.with.a.large.lace.on.the.forehead)]":{kya}
#]; 

define C1Rule1 [ Cons ([ Vow | Cons ]*) ] -> %< ... %> || .#. _ .#. ;
define C1Rule2 [..] -> %< \[%<|%>]+ %> || .#. _ %< ;
define preRedup1 LexiconClass1 .o. C1Rule1 .o. C1Rule2 ; 
define VRootClass1 _eq(preRedup1, %<, %>) .o. RemoveBrackets;

# FLAG: TOTREDUPCLASS02 / VRootTotRedupClass02 

source vroot.totredup.class02.foma 
define LexiconClass2 VRootTotRedupClass02in;

#define LexiconClass2 [ 
#  "[=mi+tot.redup@unb.copy.][VRoot][=to.jump (ES: saltar)]::[=to.jump.up-and-down]" : {mi} ! miamia
#| "[=my+tot.redup@unb.copy.][VRoot][=to.jump (ES: saltar)]::[=to.jump.up-and-down]" : {my} ! myaamyaa
#| "[=ny+INF@aantsi:agaantsi.+tot.redup@unb.copy.][VRoot][=to.see (ES: ver), to.look.for; to.visit]" : {ny}
#| "[=p+INF@aantsi.+tot.redup@unb.copy.][VRoot][=to.give (ES: dar); to.feed (ES: alimentar)]" : {p}
#]; 

define Lexicon [ LexiconClass2 EP ]; 
define C2Rule1 [ Cons ([ Vow | Cons ]*) ] -> %[ ... %] || .#. _ .#. ;
define C2Rule2 [..] -> %[ \[%[|%]]+ %] || .#. _ %[ ; 

define preRedup2 Lexicon .o. C2Rule1 .o. C2Rule2 ; 
define VRootClass2 _eq(preRedup2, %[, %]) .o. %[|%] -> 0; 

# FLAG: TOTREDUPCLASS03 / VRootTotRedupClass03 

define LexiconClass3 [ 
  "[=aa+INF@/DEL:a/gaantsi.+tot.redup@unb.copy.][VRoot][=to.take (ES: agarrar)]" : {aa} ! naanaa
| "[=aashi+INF@/EP:t/aantsi.+tot.redup@unb.copy.][VRoot][=to.make.a.group_reunion/meeting (ES: hacer.sesiÃ³n,, reunir), to.meet]" : {aashi} ! naashinaashi
]; 

define C3Lexicon [ P=1 LexiconClass3 (EP) ]; 
define C3Rule1 [ Cons ([ Vow | Cons ]*) ] -> %( ... %) || .#. _ .#. ;
define C3Rule2 [..] -> %( \[%(|%)]+ %) || .#. _ %( ; 

define preRedup3 C3Lexicon .o. C3Rule1 .o. C3Rule2 ; 
define VRootClass3 _eq(preRedup3, %(, %)) .o. %(|%) -> 0; 

read regex [ VRootClass1 | VRootClass2 | VRootClass3 ]; 

